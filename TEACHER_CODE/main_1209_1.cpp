

// 빌드
// 전처리기 -> 컴파일 -> 링킹 -> 실행파일 생성 (*.exe)

// 컴파일 : 컴파일러가 c++ 언어로 작성한 코드의 문법을 검사하고, 어셈블리 코드로 변환하는 작업 
// 전처리기 : 컴파일 단계보다 이전에 수행 

// 매크로
// 1. 코드를 일관적으로 관리
// 2. 반복되는 복잡한 구문을 편하게 생성
// 3. 가독성
#define TRUE  1
#define FALSE 0
#define MAX_MON_SPAWN 120

// 매크로 함수
#define ADD(Input1, Input2) (Input1 + Input2)




int main()
{
	// 실수 -118.625 비트 값을 정수로 해석한다면..
	float f = -118.625f;
	int* pInt = (int*) &f;
	int Test = *pInt;

	// 연산자 우선순위
	// 대입 연산자의 우선순위가 가장 느리다

	// 연산자
	// = 대입 연산자
	
	// 사칙연산
	// +, -, *, /,  %(나머지)
	// 사칙연산자 끼리 우선순위는 *, / 이 +, - 보다 높다
	// () 괄호를 이용해서 우선순위를 강제로 높힐 수 있다.

	int iData = 0; // 초기화
	iData = 100; // 대입
	iData = (3 + 5) * 2;

	float fData = 3.33333f;

	// iData 와 fData 는 표현체계가 다르기 때문에, 실수 데이터를 정수로 변환해서 덧셈을 진행하였다.
	int i = iData + (int)fData;

	int MaxHP = 1000;
	int CurHP = 600;


	// 정수끼리의 나눗셈
	// 정수 표현체계 에서는 소수점을 표현할 수 없다.
	// 연산 순서는 정수끼리의 연산이 먼저 진행기 때문에, 정수의 나눗셈으로 연산을 진행하고
	// float 타입 HPRatio 에 입력하기 위해서 float 로 변경을 한다.
	//float HPRatio = CurHP / MaxHP;

	// 나눗셈을 진행하기 전에 정수 데이터를 실수 표현체계로 변경한다
	float HPRatio = (float)CurHP / (float)MaxHP;
	
	float fResult = 10.f / 3.f;
	int iResult = 10 / 3;
	iResult = 10 % 3;


	// 참, 거짓
	// 0				: 거짓
	// 0 이 아닌 모든 수 : 참

	// 1을 대부분의 상황에서 참의 대표값으로 사용
	// 1만 참이라고 할 수 없다.
	int a = true;
	a = false;

	// 비교 연산자, 반환값이 참(1) or 거짓(0)
	// == 같은지 비교 
	// != 다른지 비교
	// <  오른쪽이 더 큰지 비교
	// >  오른쪽이 더 작은지 비교
	// <= 오른쪽이 더 크거나 같은지 비교
	// >= 오른쪽이 더 작거나 같은지 비교

	// 논리연산자
	// !	 : 참을 거짓으로, 거짓을 참으로 변경
	
	// 지역	
	// 새로운 메모리 영역을 설정해서, 같은 함수(스택) 내에서 동일한 변수명이 있어도 문제가 발생하지 않음
	{
		int iData = 100 == 111;

		iData = !false;

		int a = 0;
	}

	// 매크로 함수 주의점
	{
		// 매크로 작성 내용을 그대로 옮겨서 치환하는 것이기 때문에
		// 연산자 우선순위 문제가 발생하거나, 의도와 다르게 동작할 수 있다.
		int Data = ADD(10, 20) * 5;
		int a = 0;
	}
	



	
	return 0;
}


// 단축키
// Ctrl + Shift + B			: 빌드 실행
// F5						: 디버깅 실행(빌드, 실행)
// F10						: 중단점 지점에서 1줄 실행