

// 주석
// 메인 함수 작성
int main()
{
	// 자료형(DataType) 
	// 정수 : char(1), short(2), int(4), long(4), long long(8), __int64(8)
	// signed(양수, 음수), unsigned(양수만)
	 
	// 실수 : float(4), double(8)

	// 변수(정수, 크기는 1바이트)
	// 
	signed char Test = 0;
	int iTest = 0;

	// 정수, 실수를 표현체계가 다르다.
	// 정수
	// 1 바이트 	signed(-128 ~ 0 ~ 127), unsigned(0 ~ 255)
	// 2 바이트 0 ~ 65535
	// 4 바이트 0 ~ 대략 42억 9400만

	// 1바이트 -> 8비트
	// 1비트 -> 0, 1

	// 경우의 수, 표현 가짓수
	// 8비트는 2의 8승 가짓수(256개) 를 표현 가능
	// 숫자로 대응해보면 0 에서 255까지 표현 가능

	// 음수?
	// 가장 앞쪽에 있는 비트를 부호(양수, 음수) 판별 용도로 사용하기로 약속
	// 해당 비트를 MSB 라고 한다.
		
	// 데이터가 동일해도, 해석하는 방식에 따라서 다르게 해석할 수 있다.
	signed char sData = 255;
	unsigned char uData = 255;

	// 비트 1111 1111 ==> 양수 255, 음수 -1
	// 2의 보수법, 음수도 덧셈으로 해석한다.
	// 따라서 음의 정수는 대응하는 양의 정수랑 더했을때 0을 만들 수 있는 숫자가 되어야 한다.

	//   0000 0001
	// + 1111 1111
	// 1 0000 0000 ==> 9번째 비트는 버려진다(공간이 8비트이기 때문)

	// 2의 보수법으로 양의 정수에 대응하는 음수 찾는 방법
	// 모든 비트 각 자리를 반대로 반전시킨다음 1을 더해둔다.


	// 자료형을 혼재해서 사용하는 경우, 암묵적인 캐스팅이 발생한다.
	// char(8비트) 기준 -1 은 8개의 비트가 1로 채워진 구조
	// short(16비트) 기준 -1은 16개의 비트가 1로 채워져야 하는 구조
	char c = -1;
	short s = (short)c;



	// 부동 소수점 (정밀도)
	// 실수 : float(4), double(8)
	// 정수 타입 데이터와, 실수 타입 데이터가 연산이 섞일 경우
	// 실수 타입을 우선시한다.

	// 부동 소수점 정밀도 문제
	// 조건문
	// 반복문
	float f = 0.f; // 정수, 실수 둘다 0은 모든 비트가 0일때 0으로 본다

	// 0.2 씩 10번을 f 변수에 누적한다
	for (int i = 0; i < 10; ++i)
	{
		f = f + 0.2f;
	}

	// 최종 합산 결과가 2 로 딱 떨어지지 않는다. 
	// 0.2f 는 소수점으로서 오차가 존재함, 이걸 10번 누적하는 과정에서 오차가 더 커지게 됨
	if (f == 2.f)
	{
		int a = 0;
	}

	// 실수
	// 1. 정수와 실수 표현체계가 다르다.
	// 2. 실수는 정확도가 부족해서 여러번 연산을 누적할 경우 오차가 커질 수 있다.
	f = -118.625f;


	return 0;
}