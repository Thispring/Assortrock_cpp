// CPP 포인터
#include <iostream>

// OS - 운영체제
// 32(x86), 64(x64) 비트로 나뉨
// -> 비트 수의 차이로 인해 데이터 처리 단위가 달라짐
struct MyStruct
{
	long long verylong[100];

};

int main()
{
	// 포인터 변수
	// 주소를 저장
	int* p = nullptr;	// 64비트 OS 기준 8바이트, 32비트 OS 기준 4바이트
	char* chp = nullptr;
	// nullptr은 널포인터로 아무 주소도 가리키지 않는다는 뜻 (=숫자로 0)

	// (Q) 데이터 처리 단위를 사용자가 임의로 조정할 수 있을까?
	// 32비트 OS에서 데이터 처리 단위를 1바이트로 지정하고 char 변수 데이터를 처리한다면?

	int i = 0;
	p = &i;	// p는 i의 주소를 가리킴
		
	// 포인터와 *연산자
	// 변수 선언시 *을 붙이면 포인터 변수를 선언한다는 의미
	// *을 포인터 변수 앞에 붙이면, 포인터가 가리키는 주소로 접근한다는 의미
	// 접근하여 값을 읽어오거나, 변경이 가능

	*p = 100;
	// 포인터는 시작 주소만알고 있기에
	// 가리키고 있는 자료형의 접근 범위를 알 수 없다.
	// 
	// -> 포인터가 다른 자료형을 접근할 수 없는 이유
	// ex) int*가 char 변수의 주소를 가리키고 *연산자로 접근했을 때, int 크기 4바이트 만큼 접근하겠다고 생각함
	// char 1바이트보다 큰 숫자를 의도대로 넣을수도 없고, 만약 char 변수 메모리 뒤에 다른 변수가 존재한다면,
	// 다른 변수에 침범하여, 자료를 훼손시킬 가능성도 존재한다.
	// 
	// -> 이러한 이유로 포인터는 접근하는 단위도 자료형에 맞게 접근할 수 있도록 설계

	// 주소값은 정수표현체계로 1이 1바이트를 나타냄
	// 주소를 가질 수 있는 최소 메모리 단위는 바이트

	// 배열과 포인터
	// 배열은 메모리 공간이 연속되어있다.
	// 배열의 이름은 배열의 시작주소이다.
	int Arr[10] = {  };
	int* pArr = Arr;

	// 포인터 +1의 기준은 포인터가 가리키는 자료형의 크기 기준
	// Arr[1] = 100;과 같다.
	*(pArr + 1) = 100;

	// 구조체 포인터의 경우, 포인터가 가리키는 구조체의 바이트 크기만큼 이동
	// ex) 구조체의 크기가 120 바이트라면 (포인터 + 1)연산 시 120만큼 이동
	MyStruct st = { 0 };
	MyStruct* stp = &st;
	stp + 1;

	// const 키워드
	// 변수를 상수로 변경
	// 값을 변경시킬 수 없음
	{
		const int i = 100;
		//i = 200;
	}

	// const 포인터
	{
		// 포인터 앞에 const가 붙은, const 포인터는
		// 입력된 주소로 접근은 가능하나,
		// 접근해서 수정하는게 불가능한 포인터

		// 포인터 자체가 상수화가 되는것이 아님
		// -> 다른 변수의 주소를 가리키게 할 수 있음
		const int i = 10;
		//i = 100;

		const int j = 0;

		int* p;
		//p = &i;
		//*p = 100;

		const int* pi;
		pi = &i;
		//*pi = 100;
		std::cout << *pi << std::endl;
		pi = &j;
		std::cout << *pi << std::endl;
		
		{
			// int* 뒤에 const 키워드를 사용하면
			// int* 가 상수화되어, 다른 변수로 교체 불가
			// 값 변경은 가능

			int c = 10;
			const int d = 100;
			int e = 20;
			
			//int* const pid = &d;	// d가 const라서 참조불가
			int* const pic = &c;
			*pic = 100;
			//pic = &d;
			//pic = &e;

			// 초기화 시점에 한번만 주소를 받을 수 있으며,
			// 주소로 접근해서 수정할 수 없다.
			const int* const pConstPointer = &e;
		}

		// 일반 포인터는 접근 const 변수에 접근 자체도 못하지만
		// const 포인터는 접근해서 값만 교체가 안되기에 읽기전용 목적으로 사용
	}
	
	return 0;
}