// CPP 자료형

#include <iostream>
using namespace std;

int main() // 컴파일러의 첫 진입지점
{
	// DataType
	//
	// 정수 자료형
	// char(1), short(2), int(4), long(4), long long(8), _int64(8)

	// 실수 자료형
	// float(4), double(8)

	// 변수
	// 선언: 변수타입 변수이름 = 초기화데이터;
	char chNum = 0;
	int iNum = 1;

	// 정수와 실수를 컴퓨터는 어떻게 표현할까?
	// 컴퓨터 메모리에는 물리적인 용량 한계가 있지만
	// 소수에는 무한소수 등 무한하게 표현할 수 있는 특징이 있음

	// 정수도 숫자가 커지면 표현하는것에 한계가 존재하지만
	// 표현 한계를 범위로 정해놓아서 범위 내에서 정수를 표현
	// [EX] unsigned 1byte (0 ~ 255), 2byte(0 ~ 65535)

	// (*)게임에서 숫자를 데미지 등으로 표현하게 될때, 숫자의 범위에 따라 동작이 달라질 수 있음

	// 컴퓨터의 최소단위: 비트
	// 비트는 0과 1만 표현 가능
	// (Q*)0과 1로만 표현할 수 있는 비트로 다른 숫자를 표현하려면?
	// -> 여러개의 비트를 사용하여, 2진수 표현방법으로 다른숫자를 표현
	// 
	// 1byte -> 8bit
	// 바이트는 대문자 B, 비트는 소문자 b로 표기

	// (Q*) 컴퓨터에서 음수 표현은?
	// -> signed 자료형 맨앞의 비트를 부호비트(MSB = Most Significant Bit)로 약속하여 판별
	// 정수형의 경우, signed(음수와 양수)와 unsigned(양수만)를 통해 바이트 표현 범위를 조정할 수 있다.

	// [Lab_0]
	// 아래의 선언된 변수의 숫자 표현 확인해보기
	// (*)데이터가 동일해도, 해석하는 방식에 따라서 다르게 해석할 수 있다.
	unsigned char uData = 255;
	signed char sData = 255; // 컴파일러에서는 음수로 해석 후
	unsigned int iData = sData - 0;	// iData에 음수로 해석된 sData가 넘어감, 그렇기에 signed 여부에 따라 값이 달라짐 ex) 8비트에서 양수만 표현한다면 맨 앞 부호비트의 해석이 달라짐
	cout << "uData: " << (int)uData << endl;
	cout << "sData: " << (int)sData << endl;
	cout << "iData: " << iData << endl;

	int hexNum = 0xC;
	cout << "hex: " << hexNum << endl;

	// (*)중단점 디버깅 시 중단점 이전 코드까지만 실행

	// [Lab_1]
	// (*)CPU 회로의 최적계산을 위해 덧셈 회로만 사용 ex) +1을 했을때 0이되는 숫자는 -1
	// 컴퓨터는 더했을 때 0이되는 숫자를 음수로 판단
	// 자료형에 따라 -1의 해석이 달라진다. (자료형에 따른 표기 범위가 다르기 때문)
	// 
	// 2의 보수법(양의 정수에 대응하는 음수 찾기)
	// 모든 비트 각 자리를 반대로 반전시킨다음 1을 더해준다.

	// (*)자료형을 혼재해서 사용하는 경우, 암묵적인 캐스팅이 발생한다.
	// ex) char 기준 -1은 8개의 비트가 1로 채워진 구조
	// short 기준 -1은 16개의 비트가 1로 채워져야 하는 구조
	char c = -1;
	short s = c;

	// 부동 소수점 (정밀도)
	// (*)정수 타입 데이터와, 실수 타입 데이터가 연산이 섞일 경우
	// -> 실수 타입을 우선시한다.

	// 부동 소수점 정밀도 문제
	float f = 0.f;	// 실수 0의 비트는 모두 0으로 본다

	for (int i = 0; i < 10; ++i)
		f = f + 0.2f;

	if (f >= 2.f)
		cout << "f는 2입니다." << endl;
	else
		cout << "f는 2가 아닙니다." << endl;
	// (*)실수 데이터를 취급할 때 오차를 고려하여 조건을 만들기

	// 실수 특징
	// 1. 정수 실수 표현체계가 다르다.
	// 2. 실수는 정확도가 부족해서, 여러번 연산을 누적할 경우 오차가 커질 수 있다.

	// [Lab_2]
	// IEEE 754 소수 변환 공식
	// https://ko.wikipedia.org/wiki/IEEE_754

	// 리틀엔디안
	// https://softtone-someday.tistory.com/20
	f = -118.625;

	// 연산자

	return 0;
}